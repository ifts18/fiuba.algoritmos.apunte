\chapter{Decisiones}

\problemac{Debemos leer un número y, si el número es positivo, debemos escribir
en pantalla el cartel ``Número positivo''.}

\begin{solucion}
Especificamos nuestra solución: se deberá leer un número $x$.
Si $x > 0$ se escribe el mensaje \lstinline!"Número positivo"!.

Diseñamos nuestra solución:

\begin{enumerate}
\item Solicitar al usuario un número, guardarlo en $x$.
\item Si $x > 0$, imprimir \lstinline!"Número positivo"!
\end{enumerate}

Es claro que la primera línea se puede traducir como
\begin{codigo-python-sn}
    x = int(input("Ingrese un número: "))
\end{codigo-python-sn}

Sin embargo, con las instrucciones que vimos hasta ahora no podemos tomar
el tipo de decisiones que nos planteamos en la segunda línea de este
diseño.
\end{solucion}

Para resolver este problema introducimos una nueva instrucción que
llamaremos \emph{condicional} y tiene la siguiente forma:

\begin{codigo-python-sn}
if <condición>:
    <hacer algo si se da la condición>
\end{codigo-python-sn}

Donde \lstinline+if+ es una palabra reservada.

¿Qué es la condición que aparece luego de la palabra reservada \lstinline+if+?
Antes de seguir adelante con la construcción debemos introducir
un nuevo tipo de expresión que nos indicará si se da una cierta situación o no.
Hasta ahora las expresiones con las que trabajamos fueron de tipo numérica y de tipo texto.
Pero ahora la respuesta que buscamos es de tipo \emph{sí} o \emph{no}.

\section{Expresiones booleanas}

Además de los tipos numéricos (|int|, |float|), y las cadenas de texto (|str|),
Python introduce un tipo de dato llamado \emph{booleano} (|bool|). Una
\emph{expresión booleana} o \emph{expresión lógica} puede tomar dos valores posibles:
|True| (sí) o |False| (no).

\begin{codigo-python-sn}
>>> n = 3    # n es de tipo 'int' y toma el valor 3
>>> b = True # b es de tipo 'bool' y toma el valor True
\end{codigo-python-sn}

\subsection{Expresiones de comparación}

En el ejemplo que queremos resolver, la condición que queremos ver si se
cumple o no es que \lstinline!x! sea mayor que cero. Python provee las
llamadas \emph{expresiones de comparación} que sirven para comparar valores
entre sí, y que por lo tanto permiten codificar ese tipo de pregunta.  En
particular la pregunta de si \lstinline!x! es mayor que cero, se codifica
en Python como \lstinline!x > 0!.

De esta forma, \lstinline+5 > 3+ es una expresión booleana cuyo valor es
\lstinline!True!, y \lstinline+5 < 3+ también es una expresión booleana, pero su
valor es \lstinline!False!.

\begin{codigo-python-sn}
>>> 5 > 3
True
>>> 3 > 5
False
\end{codigo-python-sn}

Las expresiones
booleanas de comparación que provee Python son las siguientes:

\newcommand{\tablaComparacion}{
\begin{center}
\begin{tabular}[c]{l l}
{\bf Expresión} & {\bf Significado}\\
\hline
\lstinline!a == b!& \lstinline!a! es igual a \lstinline!b! \\
\lstinline+a != b+& \lstinline!a! es distinto de \lstinline!b! \\
\lstinline!a < b!& \lstinline!a! es menor que \lstinline!b! \\
\lstinline!a <= b!& \lstinline!a! es menor o igual que \lstinline!b! \\
\lstinline!a > b!& \lstinline!a! es mayor que \lstinline!b! \\
\lstinline!a >= b!& \lstinline!a! es mayor o igual que \lstinline!b! \\
\end{tabular}
\end{center}
}
\tablaComparacion

A continuación, algunos ejemplos de uso de estos operadores:

\begin{codigo-python-sn}
>>> 6 == 6
True
>>> 6 != 6
False
>>> 6 > 6
False
>>> 6 >= 6
True
>>> 6 > 4
True
>>> 6 < 4
False
>>> 6 <= 4
False
>>> 4 < 6
True
\end{codigo-python-sn}

\subsection{Operadores lógicos}

De la misma manera que se puede operar entre números mediante las
operaciones de suma, resta, etc., también existen tres operadores lógicos
para combinar expresiones booleanas: \lstinline!and! (y), \lstinline!or!
(o) y \lstinline!not! (no).

El significado de estos operadores es igual al del castellano, pero vale la pena recordarlo:

\newcommand{\tablaOperadoresLogicos}{
\begin{center}
\begin{tabular}[c]{l l}
{\bf Expresión} & {\bf Significado}\\
\hline
\lstinline!a and b!& El resultado es \lstinline!True! solamente si
\lstinline!a! es \lstinline!True! y  \lstinline!b! es \lstinline!True! \\
& de lo contrario el resultado es \lstinline!False!\\
\lstinline!a or b!& El resultado es \lstinline!True! si \lstinline!a! es
\lstinline!True! o  \lstinline!b! es \lstinline!True! (o ambos) \\
& de lo contrario el resultado es \lstinline!False!\\
\lstinline!not a!& El resultado es \lstinline!True! si \lstinline!a! es
\lstinline!False!\\
& de lo contrario el resultado es \lstinline!False!\\
\end{tabular}
\end{center}
}
\tablaOperadoresLogicos

Algunos ejemplos:

\begin{itemize}
\item \lstinline!a > b and a > c! es verdadero si \lstinline!a! es
simultáneamente mayor que \lstinline!b! y que \lstinline!c!.

\begin{codigo-python-sn}
>>> 5 > 2 and 5 > 3
True
>>> 5 > 2 and 5 > 6
False
\end{codigo-python-sn}

\item \lstinline!a > b or a > c! es verdadero si \lstinline!a! es mayor que
\lstinline!b! o \lstinline!a! es mayor que \lstinline!c!.

\begin{codigo-python-sn}
>>> 5 > 2 or 5 > 3
True
>>> 5 > 2 or 5 > 6
True
>>> 5 > 8 or 5 > 6
False
\end{codigo-python-sn}

\item \lstinline!not a > b! es verdadero si \lstinline!a > b! es falso (o
sea si \lstinline!a <= b! es verdadero).

\begin{codigo-python-sn}
>>> 5 > 8
False
>>> not 5 > 8
True
>>> 5 > 2
True
>>> not 5 > 2
False
\end{codigo-python-sn}

\end{itemize}

\section{Comparaciones simples}

Volvemos al problema que nos plantearon: Debemos leer un número y, si el
número es positivo, debemos escribir en pantalla el mensaje
 \lstinline!"Número positivo"!.

Recordemos la instrucción \lstinline!if! que acabamos de introducir y que sirve
para tomar decisiones simples. Dijimos que su formato más sencillo es:

\begin{codigo-python-sn}
if <condición>:
    <hacer algo si se da la condición>
\end{codigo-python-sn}

cuyo significado es el siguiente:
se evalúa |<condición>| (que debe ser una expresión lógica), y si el resultado
es |True| (verdadero) se ejecutan las acciones indicadas como
|<hacer algo si se da la condición>|.

Como ahora ya sabemos también cómo construir condiciones de comparación,
estamos en condiciones de implementar nuestra solución. Escribimos la
función \lstinline+positivo()+ que hace lo pedido:

\begin{codigo-python-sn}
def positivo():
    x = int(input("Ingrese un número: "))
    if x > 0:
        print("Número positivo")
\end{codigo-python-sn}

y la probamos:

\begin{codigo-python-sn}
>>> positivo()
Ingrese un número: 4
Número positivo
>>> positivo()
Ingrese un número: -25
>>> positivo()
Ingrese un número: 0
\end{codigo-python-sn}

\problemac{%
Necesitamos además un mensaje \lstinline!"Número no positivo"! cuando no se cumple
la condición.}

Modificamos la especificación consistentemente y modificamos el diseño:

\begin{enumerate}
\item Solicitar al usuario un número, guardarlo en $x$.
\item Si $x > 0$, imprimir \lstinline!"Número positivo"!
\item En caso contrario, imprimir \lstinline!"Número no positivo"!
\end{enumerate}

La negación de $x> 0 $ es $\neg(x > 0)$ que se traduce en Python como
|not x > 0|, por lo que implementamos nuestra solución en
Python como:

\begin{codigo-python-sn}
def positivo_o_no():
    x = int(input("Ingrese un número: "))
    if x > 0: (~\circled{1}~)
       print("Número positivo")
    (@if not x > 0:@) (~\circled{2}~)
       print("Número no positivo")
\end{codigo-python-sn}

Probamos la nueva solución y obtenemos el resultado buscado:

\begin{codigo-python-sn}
>>> positivo_o_no()
Ingrese un número: 4
Número positivo
>>> positivo_o_no()
Ingrese un número: -25
Número no positivo
>>> positivo_o_no()
Ingrese un número: 0
Número no positivo
\end{codigo-python-sn}

Sin embargo hay algo que nos preocupa: si ya averiguamos una vez, en
\circled{1}, si \lstinline!x > 0!, ¿Es realmente necesario volver a
preguntarlo en \circled{2}?.

Existe una construcción alternativa para la estructura de decisión:

{\bf Si se da la condición C, hacer S, de lo contrario, hacer T}. Esta estructura tiene la forma:

\begin{codigo-python-sn}
if <condición>:
    <hacer algo si se da la condición>
else:
    <hacer otra cosa si no se da la condición>
\end{codigo-python-sn}

Donde \lstinline!if! y \lstinline!else! son palabras reservadas.

Su significado es el siguiente: se evalúa |<condición>|, si el
resultado es |True| se ejecutan las acciones
indicadas como |<hacer algo si se da la condición|, y si el
resultado es |False| se ejecutan las acciones indicadas
como |<hacer otra cosa si no se da la condición>|.

Volvemos a nuestro diseño:

\begin{enumerate}
\item Solicitar al usuario un número, guardarlo en $x$.
\item Si $x > 0$, imprimir \lstinline!"Número positivo"!
\item En caso contrario, imprimir \lstinline!"Número no positivo"!
\end{enumerate}

Este diseño se implementa como:

\begin{codigo-python-sn}
def positivo_o_no():
    x = int(input("Ingrese un número: "))
    if x > 0:
       print("Número positivo")
    (@else:@)
       print("Número no positivo")
\end{codigo-python-sn}

y lo probamos:

\begin{codigo-python-sn}
>>> positivo_o_no()
Ingrese un número: 4
Número positivo
>>> positivo_o_no()
Ingrese un número: -25
Número no positivo
>>> positivo_o_no()
Ingrese un número: 0
Número no positivo
\end{codigo-python-sn}

Es importante destacar que, en general, negar la condición del
\lstinline!if! y poner \lstinline!else! no son intercambiables, porque no
necesariamente producen el mismo efecto en el programa. Notar qué sucede en
los dos programas que se transcriben a continuación. ¿Por qué se dan estos
resultados?:

\noindent
\begin{minipage}[t]{80mm}
\begin{codigo-python-sn-small}
>>> def pn1():
...   x = int(input("Ingrese un nro: "))
...   if x > 0:
...      print("Número positivo")
...      x = -x
...   (@if x < 0:@)
...      print("Número no positivo")
...
>>> pn1()
Ingrese un nro: 25
Número positivo
Número no positivo
\end{codigo-python-sn-small}
\end{minipage}
\begin{minipage}[t]{80mm}
\begin{codigo-python-sn-small}
>>> def pn2():
...   x = int(input("Ingrese un nro: "))
...   if x > 0:
...      print("Número positivo")
...      x = -x
...   (@else:@)
...      print("Número no positivo")
...
>>> pn2()
Ingrese un nro: 25
Número positivo
\end{codigo-python-sn-small}
\end{minipage}
\normalsize

\section{Múltiples decisiones consecutivas}

La decisión de incluir una decisión en un programa, parte de una
lectura cuidadosa de la especificación. En nuestro caso la especificación
nos decía:

\begin{quote}
Si el número es positivo escribir un mensaje
\lstinline!"Número positivo"!, de lo contrario escribir un mensaje
\lstinline!"Número no positivo"!.
\end{quote}

Veamos qué se puede hacer cuando se presentan tres o más alternativas:

\problemac{%
Si el número es positivo escribir un mensaje
\lstinline!"Número positivo"!, si el número es igual a 0 un mensaje
\lstinline!"Igual a 0"!, y si el número es negativo escribir un mensaje
\lstinline!"Número negativo"!}.

Una posibilidad es considerar que se trata de una estructura con dos
casos como antes, sólo que el segundo caso es complejo (es nuevamente una alternativa):

\begin{enumerate}
\item Solicitar al usuario un número, guardarlo en \lstinline!x!.
\item Si $x > 0$, imprimir \lstinline!"Número positivo"!
\item De lo contrario:
\begin{enumerate}
\item Si $x = 0$, imprimir \lstinline!"Igual a 0"!
\item De lo contrario, imprimir \lstinline!"Número no positivo"!
\end{enumerate}
\end{enumerate}

Este diseño se implementa como:

\begin{codigo-python-sn}
def pos_cero_o_neg():
    x = int(input("Ingrese un número: "))
    if x > 0:
        print("Número positivo")
    else:
        if x == 0:
            print("Igual a 0")
        else:
            print("Número negativo")
\end{codigo-python-sn}

Esta estructura se conoce como de \emph{alternativas anidadas} ya que dentro
de una de las ramas de la alternativa (en este caso la rama del
\lstinline!else!) se anida otra alternativa.

Pero ésta no es la única forma de implementarlo. Existe otra construcción,
equivalente a la anterior pero que no exige sangrías cada vez mayores en el texto.
Se trata de la estructura de \emph{alternativas encadenadas}, que tiene la forma

\begin{codigo-python-sn}
if <condición_1>:
    <hacer algo_1 si se da la condición_1>
elif <condición_2>:
    <hacer algo_2 si se da la condición_2>
...
...
elif <condición_n>:
    <hacer algo_n si se da la condición_n>
else:
    <hacer otra cosa si no se da ninguna de las condiciones anteriores>
\end{codigo-python-sn}

Donde \lstinline!if!, \lstinline!elif! y \lstinline!else! son palabras reservadas.

En nuestro ejemplo:

\begin{codigo-python-sn}
def pos_cero_o_neg():
    x = int(input("Ingrese un número: "))
    if x > 0:
       print("Número positivo")
    (@elif x == 0:@)
       print("Igual a 0")
    else:
       print("Número negativo")
\end{codigo-python-sn}

Se evalúa la primera alternativa, si es verdadera se ejecuta su cuerpo.  De
lo contrario se evalúa la segunda alternativa, si es verdadera se ejecuta
su cuerpo, etc.  Finalmente, si todas las alternativas anteriores fallaron,
se ejecuta el cuerpo del \lstinline!else!.

\begin{sabias_que}
No sólo mediante los operadores vistos (como \lstinline!>! o \lstinline!==!)
es posible obtener expresiones booleanas.  En Python, se consideran
\textit{verdaderos} los valores numéricos distintos de 0, las cadenas de
caracteres que no son vacías, y en general cualquier valor que no sea 0 o
vacío.  Mientras que los valores nulos o vacíos se consideran \textit{falsos}.

Así, en el ejemplo anterior la línea

\begin{codigo-python-sn}
elif x == 0:
\end{codigo-python-sn}

también podría escribirse de la siguiente manera:

\begin{codigo-python-sn}
elif not x:
\end{codigo-python-sn}

Además, en Python existe un valor especial llamado |None| que se utiliza
comúnmente para representar la ausencia de un valor. Podemos preguntar si una
variable |v| es |None| simplemente con:

\begin{codigo-python-sn}
if v is None:
\end{codigo-python-sn}

O, como |None| también es considerado un valor nulo,

\begin{codigo-python-sn}
if not v:
\end{codigo-python-sn}
\end{sabias_que}


\section{Ejercicios}

\ejercicioc{El usuario del tarifador nos pide ahora una modificación, ya
que no es lo mismo la tarifa por segundo de las llamadas cortas que la
tarifa por segundo de las llamadas largas.  Al inicio del programa se
informará la duración máxima de una llamada corta, la tarifa de las
llamadas cortas y la de las largas. Se deberá facturar con alguno de los
dos valores de acuerdo a la duración de la comunicación.}

\ejercicioc{{\bf Mantenimiento del tarifador:}

\begin{partes}
\item Al nuevo programa que cuenta con llamadas cortas y largas, agregarle
los adicionales, de modo que:
\begin{itemize}
\item Los montos se escriban como pesos y centavos.
\item Se informe además cuál fue el total facturado en la corrida.
\end{itemize}

\item Modificar el programa para que sólo informe cantidad de llamadas
cortas, valor total de llamadas cortas facturadas, cantidad de llamadas
largas, valor total de llamadas largas facturadas, y total facturado.
Al llegar a este punto debería ser evidente que es conveniente separar los
cálculos en funciones aparte.
\end{partes}
}

\ejercicioc{Dados tres puntos en el plano expresados como coordenadas $(x, y)$
informar cuál es el que se encuentra más lejos del centro de
coordenadas.}

\section{Resumen}
\begin{itemize}
\item Para poder tomar decisiones en los programas y ejecutar una acción u
otra, es necesario contar con una \textbf{estructura condicional}.
\item Las \textbf{condiciones} son expresiones \textit{booleanas}, es
decir, cuyos valores pueden ser \textit{verdadero} o \textit{falso}, y se
las confecciona mediante operadores entre distintos valores.
\item Mediante \textbf{expresiones lógicas} es posible modificar o combinar
expresiones booleanas.
\item La estructura condicional puede contar, opcionalmente, con un bloque
de código que se ejecuta si no se cumplió la condición.
\item Es posible \textit{anidar} estructuras condicionales, colocando una
dentro de otra.
\item También es posible \textit{encadenar} las condiciones, es decir,
colocar una lista de posibles condiciones, de las cuales se ejecuta la
primera que sea verdadera.
\end{itemize}

\begin{referencia_python}

\begin{sintaxis}{\lstinline!if <condición>:!}
Bloque condicional.  Las acciones a ejecutar si la condición
es verdadera deben tener un mayor nivel de sangría.
\begin{codigo-python-sn}
if <condición>:
    # acciones a ejecutar si condición es verdadera
\end{codigo-python-sn}
\end{sintaxis}

\begin{sintaxis}{\lstinline!else:!}
Un bloque que se ejecuta cuando no se cumple la condición
correspondiente al \lstinline!if!.  Sólo se puede utilizar
\lstinline!else! si hay un \lstinline!if! correspondiente.  Debe
escribirse al mismo nivel que \lstinline!if!, y las acciones a ejecutar
deben tener un nivel de sangría mayor.
\begin{codigo-python-sn}
if <condición>:
    # acciones a ejecutar si condición es verdadera
else:
    # acciones a ejecutar si condición es falsa
\end{codigo-python-sn}
\end{sintaxis}

\begin{sintaxis}{\lstinline!elif <condición>:!}
Bloque que se ejecuta si no se cumplieron las condiciones
anteriores pero sí se cumple la condición especificada.  Sólo se puede utilizar
\lstinline!elif! si hay un \lstinline!if! correspondiente, se lo debe
escribir al mismo nivel que \lstinline!if!, y las acciones a ejecutar deben
escribirse en un bloque de sangría mayor.  Puede haber tantos
\lstinline!elif! como se quiera, todos al mismo nivel.
\begin{codigo-python-sn}
if <condición1>:
    # acciones a ejecutar si condición1 es verdadera
elif <condición2>:
    # acciones a ejecutar si condición2 es verdadera
else:
    # acciones a ejecutar si ninguna condición fue verdadera
\end{codigo-python-sn}
\end{sintaxis}

\begin{sintaxis}{Operadores de comparación}
Son los que forman las expresiones booleanas.

\tablaComparacion
\end{sintaxis}

\begin{sintaxis}{Operadores lógicos}
Son los utilizados para concatenar o negar distintas expresiones booleanas.

\tablaOperadoresLogicos
\end{sintaxis}

\end{referencia_python}


\newpage
\section{Ejercicios}

\extractionlabel{guia}
\begin{ejercicio} Escribir dos funciones que resuelvan los siguientes problemas:
\begin{partes}
    \item Dado un número entero $n$, indicar si es par o no.
    \item Dado un número entero $n$, indicar si es primo o no.
\end{partes}
\end{ejercicio}

\extractionlabel{guia}
\begin{ejercicio}
Escribir una implementación propia de la función \verb!abs!, que devuelva
el valor absoluto de cualquier valor que reciba.
\end{ejercicio}

\extractionlabel{guia}
\begin{ejercicio}
Escribir una función que reciba por parámetro una dimensión $n$, e imprima
la matriz identidad correspondiente a esa dimensión.
\end{ejercicio}

\extractionlabel{guia}
\begin{ejercicio}
Escribir funciones que permitan encontrar:
\begin{partes}

    \item  El máximo o mínimo de un polinomio de segundo grado (dados los
coeficientes \verb!a!, \verb!b! y \verb!c!), indicando si es un máximo o un
mínimo.

    \item Las raíces (reales o complejas) de un polinomio de segundo grado. \\
{\bf Nota}: validar que las operaciones puedan efectuarse antes de
realizarlas (no dividir por cero, ni calcular la raíz de un número negativo).

    \item La intersección de dos rectas (dadas las pendientes y ordenada
 al origen de cada recta). \\
{\bf Nota}: validar que no sean dos rectas con la misma pendiente, antes de
efectuar la operación.
\end{partes}
\end{ejercicio}


\extractionlabel{guia}
\begin{ejercicio} Escribir funciones que resuelvan los siguientes problemas:
\begin{partes}
    \item Dado un año indicar si es bisiesto. \\
{\bf Nota}: un año es bisiesto si es un número divisible por 4, pero no si es
divisible por 100, excepto que también sea divisible por 400.

    \item Dado un mes, devolver la cantidad de días correspondientes.

    \item Dada una fecha (día, mes, año), indicar si es válida o no.

    \item Dada una fecha, indicar los días que faltan hasta fin de mes.

    \item Dada una fecha, indicar los días que faltan hasta fin de año.

    \item Dada una fecha, indicar la cantidad de días transcurridos en ese año
hasta esa fecha.

    \item Dadas dos fechas (día1, mes1, año1, día2, mes2, año2), indicar el
tiempo transcurrido entre ambas, en años, meses y días.
\end{partes}
{\bf Nota}: en todos los casos, invocar las funciones escritas previamente
cuando sea posible.
\end{ejercicio}


\extractionlabel{guia}
\begin{ejercicio}
Suponiendo que el primer día del año fue lunes, escribir una función
que reciba un número con el día del año (de 1 a 366) y devuelva el día
de la semana que le toca. Por ejemplo: si recibe \verb|'3'| debe devolver
\verb|'miércoles'|, si recibe \verb|'9'| debe devolver \verb|'martes'|.
\end{ejercicio}


\extractionlabel{guia}
\begin{ejercicio}
$\bigstar$ Escribir un programa que reciba como entrada un entero representando un año
(por ejemplo 751, 1999, o 2158), y muestre por pantalla el mismo año escrito en
números romanos.
\end{ejercicio}


\extractionlabel{guia}
\begin{ejercicio}
Programa de astrología: el usuario debe ingresar el día y mes de su cumpleaños
y el programa le debe decir a qué signo corresponde.

{\footnotesize
\begin{center}
\begin{tabular}[c]{l l}
Aries: 21 de marzo al 20 de abril. & Tauro: 21 de abril al 20 de mayo. \\
Geminis: 21 de mayo al 21 de junio. & Cancer: 22 de junio al 23 de julio. \\
Leo: 24 de julio al 23 de agosto. & Virgo: 24 de agosto al 23 de septiembre. \\
Libra: 24 de septiembre al 22 de octubre. & Escorpio: 23 de octubre al 22 de noviembre. \\
Sagitario: 23 de noviembre al 21 de diciembre. & Capricornio: 22 de diciembre al 20 de enero. \\
Acuario: 21 de enero al 19 de febrero. & Piscis: 20 de febrero al 20 de marzo. \\
\end{tabular}
\end{center}
}
\end{ejercicio}
